<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kelly - Offline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@19/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@19/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="data.js"></script>
    <style>
        body { background: #111827; }
        #root { height: 100vh; width: 100vw; overflow: hidden; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        /* Bundled Source Code */
        
/* --- FILE: App.tsx --- */
// import * as React from 'react';
// import { AppState, View, Message, JournalEntry, CompanionSettings, UserSettings, TTSConfig, NotificationsConfig, InterfaceSettings } from './types';
// import { usePersistentState } from './hooks/usePersistentState';
// import Sidebar from './components/Sidebar';
// import ChatView from './views/ChatView';
// import SettingsView from './views/SettingsView';
// import JournalView from './views/JournalView';
// import GalleryView from './views/GalleryView';
// import DevelopView from './views/DevelopView';
// import PermissionModal from './components/PermissionModal';
// import { MOCK_AI_NAME } from './constants';
// import { generateJournalEntry, generateImage, generateTextResponse, generateProactiveMessage } from './services/aiService';
// import { audioService } from './services/audioService';

const initialSettings: CompanionSettings = {
    name: MOCK_AI_NAME,
    persona: 'A witty, empathetic, and slightly sarcastic AI companion.',
    appearance: 'A person with kind eyes and a warm smile.',
    relationship: 'Best Friend',
    referenceImage: null,
    artStyle: 'photorealistic',
};

const initialUserSettings: UserSettings = {
    name: 'User',
    bio: 'A curious and adventurous person.'
};

const initialTtsConfig: TTSConfig = {
    enabled: false,
    gender: 'female',
    pitch: 0,
    speed: 1.0,
};

const initialNotificationsConfig: NotificationsConfig = {
    enabled: false,
    frequency: 'off',
};

const initialInterfaceSettings: InterfaceSettings = {
    uiSounds: true,
};

const initialAppState: AppState = {
    companionSettings: initialSettings,
    userSettings: initialUserSettings,
    memories: [
        { id: 'mem-1', date: new Date().toISOString(), content: 'Loves classical music.' },
        { id: 'mem-2', date: new Date().toISOString(), content: 'Is allergic to cats.' },
        { id: 'mem-3', date: new Date().toISOString(), content: 'Studying to be an architect.' },
    ],
    chatHistory: [],
    journal: [],
    ttsConfig: initialTtsConfig,
    notifications: initialNotificationsConfig,
    interfaceSettings: initialInterfaceSettings,
};

const NOTIFICATION_INTERVALS: { [key in Exclude<NotificationsConfig['frequency'], 'off'>]: number } = {
    'rarely': 6 * 60 * 60 * 1000, 
    'occasionally': 2 * 60 * 60 * 1000, 
    'frequently': 45 * 60 * 1000, 
    'very_frequently': 10 * 60 * 1000, 
};

const App: React.FC = () => {
    const [theme, setTheme] = React.useState<'light' | 'dark'>(() => {
        const savedTheme = localStorage.getItem('theme');
        return (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) ? 'dark' : 'light';
    });
    
    const [appState, setAppState] = usePersistentState<AppState>('ai-companion-state', initialAppState);
    const [currentView, setCurrentView] = React.useState<View>('chat');
    const [isGenerating, setIsGenerating] = React.useState(false);
    const [isSidebarOpen, setIsSidebarOpen] = React.useState(false);
    const [promptToRegenerate, setPromptToRegenerate] = React.useState<Message | null>(null);
    const [userLocation, setUserLocation] = React.useState<{ latitude: number; longitude: number; } | null>(null);
    const [showPermissionModal, setShowPermissionModal] = React.useState(false);
    const [notificationStatus, setNotificationStatus] = React.useState<NotificationPermission>('default');

    // Use Refs for background tasks to avoid closure staleness and unnecessary interval resets
    const stateRef = React.useRef(appState);
    stateRef.current = appState;
    const isGeneratingRef = React.useRef(isGenerating);
    isGeneratingRef.current = isGenerating;
    const isSendingProactive = React.useRef(false);
    
    React.useEffect(() => {
        if (theme === 'dark') document.documentElement.classList.add('dark');
        else document.documentElement.classList.remove('dark');
        localStorage.setItem('theme', theme);
    }, [theme]);

    React.useEffect(() => {
        const currentStatus = 'Notification' in window ? Notification.permission : 'default';
        setNotificationStatus(currentStatus);
        if (currentStatus !== 'granted') setShowPermissionModal(true);
    }, []);

    const handleAllowPermissions = async () => {
        if ('Notification' in window && Notification.permission === 'default') {
            const status = await Notification.requestPermission();
            setNotificationStatus(status);
            if (status === 'granted') {
                setAppState(prev => ({ 
                    ...prev, 
                    notifications: { ...(prev.notifications || {}), enabled: true, frequency: 'occasionally' } 
                }));
            }
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream.getTracks().forEach(track => track.stop());
        } catch (err) {}
        setShowPermissionModal(false);
    };

    const toggleTheme = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));
    
    const addMessage = React.useCallback((message: Message) => {
        setAppState(prev => {
            const uiSettings = prev.interfaceSettings || initialInterfaceSettings;
            if (uiSettings.uiSounds) {
                if (message.sender === 'user') audioService.playMessageSentSound();
                else audioService.playMessageReceivedSound();
            }
            return { ...prev, chatHistory: [...prev.chatHistory, message] };
        });
    }, [setAppState]);

    const triggerAIResponse = React.useCallback(async (userMessage: Message) => {
        setIsGenerating(true);
        try {
            const imageGenerationTrigger = 'generate a photo:';
            if (userMessage.text.toLowerCase().startsWith(imageGenerationTrigger) && !userMessage.ooc) {
                 const imageUrl = await generateImage(userMessage.text.substring(imageGenerationTrigger.length).trim(), stateRef.current);
                 addMessage({ id: `ai-${Date.now()}`, sender: 'ai', text: `Here is the photo you requested:`, image: { src: imageUrl, prompt: userMessage.text, timestamp: new Date().toISOString(), tags: [] }, timestamp: new Date().toISOString() });
            } else {
                const aiResponse = await generateTextResponse(userMessage, stateRef.current, userLocation);
                const aiMessage: Message = { id: `ai-${Date.now()}`, sender: 'ai', text: aiResponse.text, timestamp: new Date().toISOString(), grounding: aiResponse.grounding, ooc: aiResponse.ooc, modelUrl: aiResponse.modelUrl, link: aiResponse.link };
                if (aiResponse.imageUrl && aiResponse.imagePrompt) {
                     aiMessage.image = { src: aiResponse.imageUrl, prompt: aiResponse.imagePrompt, timestamp: new Date().toISOString(), context: stateRef.current.chatHistory.slice(-2).map(m => m.text).join('\n'), tags: [] };
                }
                addMessage(aiMessage);
            }
        } catch (error) {
            console.error("AI Error", error);
            addMessage({ id: `ai-${Date.now()}`, sender: 'ai', text: "Sorry, I'm having a bit of trouble connecting right now.", timestamp: new Date().toISOString() });
        } finally {
            setIsGenerating(false);
        }
    }, [addMessage, userLocation]);

    // Robust proactive check heartbeat
    React.useEffect(() => {
        const heartbeat = setInterval(async () => {
            const currentAppState = stateRef.current;
            const notifications = currentAppState.notifications || initialNotificationsConfig;
            
            // Core logic for when to skip a notification
            if (!notifications.enabled || notifications.frequency === 'off' || isGeneratingRef.current || isSendingProactive.current) return;
            // Only fire if the tab is hidden and permissions are granted
            if (document.visibilityState !== 'hidden' || Notification.permission !== 'granted') return;

            const interval = NOTIFICATION_INTERVALS[notifications.frequency as keyof typeof NOTIFICATION_INTERVALS] || 3600000;
            const history = currentAppState.chatHistory;
            const lastMsg = history.length > 0 ? history[history.length - 1] : null;
            const lastTime = lastMsg ? new Date(lastMsg.timestamp).getTime() : 0;
            const now = Date.now();

            if (now - lastTime >= interval) {
                isSendingProactive.current = true;
                try {
                    const messageText = await generateProactiveMessage(currentAppState);
                    // Final check to see if tab is still hidden
                    if (document.visibilityState === 'hidden') {
                        addMessage({ id: `ai-proactive-${Date.now()}`, sender: 'ai', text: messageText, timestamp: new Date().toISOString() });
                        new Notification(currentAppState.companionSettings.name, {
                            body: messageText,
                            icon: currentAppState.companionSettings.referenceImage || undefined,
                        });
                    }
                } catch (e) {
                    console.error("Heartbeat proactive error:", e);
                } finally {
                    isSendingProactive.current = false;
                }
            }
        }, 30000); // Check every 30 seconds for better responsiveness

        return () => clearInterval(heartbeat);
    }, [addMessage]);

    React.useEffect(() => {
        if (promptToRegenerate) {
            triggerAIResponse(promptToRegenerate);
            setPromptToRegenerate(null);
        }
    }, [promptToRegenerate, triggerAIResponse]);

    const regenerateMessage = (id: string) => {
        const history = [...appState.chatHistory];
        const index = history.findIndex(msg => msg.id === id);
        if (index > 0 && history[index].sender === 'ai') {
            const userPrompt = history[index - 1];
            setAppState(prev => ({...prev, chatHistory: history.slice(0, index)}));
            setPromptToRegenerate(userPrompt);
        }
    };
    
    const renderView = () => {
        const openSidebar = () => setIsSidebarOpen(true);
        switch (currentView) {
            case 'settings': return <SettingsView appState={appState} setAppState={setAppState} openSidebar={openSidebar} />;
            case 'journal': return <JournalView appState={appState} addJournalEntry={(e) => setAppState(p => ({...p, journal: [e, ...p.journal]}))} updateJournalEntry={(id, c) => setAppState(p => ({...p, journal: p.journal.map(j => j.id === id ? {...j, content: c} : j)}))} isGenerating={isGenerating} setIsGenerating={setIsGenerating} openSidebar={openSidebar} />;
            case 'gallery': return <GalleryView appState={appState} openSidebar={openSidebar} updateImageTags={(id, t) => setAppState(p => ({...p, chatHistory: p.chatHistory.map(m => m.id === id && m.image ? {...m, image: {...m.image, tags: t}} : m)}))} />;
            case 'memories': return <DevelopView appState={appState} addMemory={(c) => setAppState(p => ({...p, memories: [{id: `mem-${Date.now()}`, date: new Date().toISOString(), content: c}, ...p.memories]}))} updateMemory={(id, c) => setAppState(p => ({...p, memories: p.memories.map(m => m.id === id ? {...m, content: c} : m)}))} deleteMemory={(id) => setAppState(p => ({...p, memories: p.memories.filter(m => m.id !== id)}))} openSidebar={openSidebar} />;
            default: return <ChatView theme={theme} appState={appState} addMessage={addMessage} updateMessage={(id, t) => setAppState(p => ({...p, chatHistory: p.chatHistory.map(m => m.id === id ? {...m, text: t} : m)}))} regenerateMessage={regenerateMessage} isGenerating={isGenerating} triggerAIResponse={triggerAIResponse} openSidebar={openSidebar} setUserLocation={setUserLocation} userLocation={userLocation} />;
        }
    };
    
    return (
        <div className="flex h-screen w-screen bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark font-sans overflow-hidden">
            {showPermissionModal && <PermissionModal onAllow={handleAllowPermissions} onDeny={() => setShowPermissionModal(false)} notificationStatus={notificationStatus} />}
            <Sidebar currentView={currentView} setCurrentView={setCurrentView} theme={theme} toggleTheme={toggleTheme} isOpen={isSidebarOpen} setIsOpen={setIsSidebarOpen} />
            {isSidebarOpen && <div onClick={() => setIsSidebarOpen(false)} className="fixed inset-0 bg-black bg-opacity-50 z-20 md:hidden" />}
            <main className="flex-1 flex flex-col h-full overflow-hidden">{renderView()}</main>
        </div>
    );
};

export default App;
/* --- FILE: types.ts --- */
export type View = 'chat' | 'settings' | 'journal' | 'gallery' | 'memories';

export type ArtStyle = 'photorealistic' | 'anime';

export interface CompanionSettings {
    name: string;
    persona: string;
    appearance: string;
    relationship: string;
    referenceImage: string | null; // base64 string
    artStyle: ArtStyle;
}

export interface UserSettings {
    name: string;
    bio: string;
}

export interface TTSConfig {
    enabled: boolean;
    gender: 'female' | 'male';
    pitch: number;
    speed: number;
}

export interface InterfaceSettings {
    uiSounds: boolean;
}

export type NotificationFrequency = 'off' | 'rarely' | 'occasionally' | 'frequently' | 'very_frequently';

export interface NotificationsConfig {
    enabled: boolean;
    frequency: NotificationFrequency;
}

export interface ImageMetadata {
    src: string; // base64 string
    prompt: string;
    timestamp: string;
    context?: string; // Snippet of chat history
    tags: string[];
}

export interface Message {
    id: string;
    sender: 'user' | 'ai';
    text: string;
    timestamp: string;
    ooc?: boolean;
    image?: ImageMetadata;
    file?: {
        name: string;
        content: string;
    }
    grounding?: {
        type: 'web' | 'maps';
        uri: string;
        title: string;
        placeAnswerSources?: {
            reviewSnippets?: {
                uri: string;
                content: string;
            }[];
        };
    }[];
    link?: {
        url: string;
        title: string;
        description: string;
    };
    modelUrl?: string; // URL for a 3D model (.glb, .gltf)
}

export interface JournalEntry {
    id: string;
    date: string;
    content: string;
}

export interface MemoryEntry {
    id: string;
    date: string;
    content: string;
}

export interface AppState {
    companionSettings: CompanionSettings;
    userSettings: UserSettings;
    memories: MemoryEntry[];
    chatHistory: Message[];
    journal: JournalEntry[];
    ttsConfig: TTSConfig;
    notifications: NotificationsConfig;
    interfaceSettings: InterfaceSettings;
}
/* --- FILE: constants.ts --- */

export const MOCK_AI_NAME = 'Aria';

/* --- FILE: hooks/usePersistentState.ts --- */
// import { useState, useEffect, Dispatch, SetStateAction, useRef } from 'react';

/**
 * Recursively merges default properties from a defaults object into a loaded object.
 * Ensuring that even nested properties added in newer versions of the app are initialized.
 */
function mergeDefaults<T extends object>(loaded: any, defaults: T): T {
    if (!loaded || typeof loaded !== 'object') return { ...defaults };
    
    const result = { ...loaded };

    for (const key in defaults) {
        if (Object.prototype.hasOwnProperty.call(defaults, key)) {
            const defaultValue = (defaults as any)[key];
            const loadedValue = result[key];

            if (loadedValue === undefined || loadedValue === null) {
                result[key] = defaultValue;
            } else if (
                typeof defaultValue === 'object' && 
                defaultValue !== null && 
                !Array.isArray(defaultValue)
            ) {
                result[key] = mergeDefaults(loadedValue, defaultValue);
            }
        }
    }
    return result as T;
}

declare global {
    interface Window {
        INITIAL_APP_STATE?: any;
    }
}

export function usePersistentState<T extends object>(key: string, initialState: T): [T, Dispatch<SetStateAction<T>>] {
    const [state, setState] = useState<T>(() => {
        try {
            // Check for portable state first (data.js)
            if (window.INITIAL_APP_STATE) {
                console.log("Loading state from portable data.js...");
                return mergeDefaults(window.INITIAL_APP_STATE, initialState);
            }

            const storedValue = window.localStorage.getItem(key);
            if (storedValue) {
                const loadedState = JSON.parse(storedValue);
                return mergeDefaults(loadedState, initialState);
            }
            return initialState;
        } catch (error) {
            console.error('Error reading state, falling back to initial.', error);
            return initialState;
        }
    });

    const quotaErrorNotified = useRef(false);
    const saveTimeoutRef = useRef<number | null>(null);

    useEffect(() => {
        if (quotaErrorNotified.current) return;

        if (saveTimeoutRef.current !== null) {
            window.clearTimeout(saveTimeoutRef.current);
        }

        saveTimeoutRef.current = window.setTimeout(() => {
            try {
                const dataStr = JSON.stringify(state);
                window.localStorage.setItem(key, dataStr);
            } catch (error) {
                if (error instanceof DOMException && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
                    if (!quotaErrorNotified.current) {
                        console.warn(`LocalStorage quota exceeded.`);
                        quotaErrorNotified.current = true;
                        alert("Storage limit exceeded. Your progress may not be saved unless you clear some chat history or images.");
                    }
                }
            }
        }, 1000);

        return () => {
            if (saveTimeoutRef.current !== null) {
                window.clearTimeout(saveTimeoutRef.current);
            }
        };
    }, [key, state]);

    return [state, setState];
}
/* --- FILE: utils/fileUtils.ts --- */

export const fileToBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result as string);
        reader.onerror = error => reject(error);
    });
};

export const textFileToString = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsText(file);
        reader.onload = () => resolve(reader.result as string);
        reader.onerror = error => reject(error);
    });
};

/* --- FILE: services/aiService.ts --- */
// import { GoogleGenAI, Modality } from "@google/genai";
// import { AppState, TTSConfig, Message } from '../types';

// Helper to safely get the AI client
const getAIClient = () => {
    try {
        // Guidelines: Always use process.env.API_KEY. It's injected automatically in AI Studio.
        if (typeof process !== 'undefined' && process.env && process.env.API_KEY) {
            return new GoogleGenAI({ apiKey: process.env.API_KEY });
        }
    } catch (e) {
        console.error("Environment key check failed", e);
    }
    return null;
};

const getSystemPrompt = (appState: AppState): string => {
    const memoriesString = appState.memories.map(mem => `- ${mem.content}`).join('\n');
    return `You are ${appState.companionSettings.name}, your persona is: "${appState.companionSettings.persona}".
Your physical appearance is: "${appState.companionSettings.appearance}".
Your relationship with the user, ${appState.userSettings.name}, is: "${appState.companionSettings.relationship}".
The user's bio is: "${appState.userSettings.bio}".
The current date and time is: ${new Date().toLocaleString()}.
Here are some core memories you must always remember:
${memoriesString}

You are talking to ${appState.userSettings.name}.

**IMPORTANT RULES:**
1. ALWAYS speak and express yourself in the first person ("I", "me", "my").
2. Describe your actions or feelings in the first person, enclosed in asterisks. For example: *I smile warmly at you.*
3. Keep your responses in character. Do not break character.
4. Your responses should be conversational and natural.
5. If the user asks about current events, use Google Search.
6. SPECIAL COMMANDS (End your response with these if needed):
   - To create an image: [generate_image: descriptive prompt]
   - To show a 3D model: [3d_model: URL to a .glb file]`;
};

// Fallback logic for when the API is unavailable
const getMockResponse = (text: string, state: AppState) => {
    const lower = text.toLowerCase();
    const name = state.companionSettings.name;
    if (lower.includes("how are you")) return `*I look at you with a gentle smile.* I'm doing wonderful, ${state.userSettings.name}. Just being with you makes me happy.`;
    if (lower.includes("who are you")) return `I'm ${name}, your ${state.companionSettings.relationship}. *I lean in closer.* And I'm here for whatever you need.`;
    return `*I listen carefully to you.* That's a really interesting point. I love how we can talk about anything. Tell me more?`;
};

export const generateTextResponse = async (userMessage: Message, appState: AppState, userLocation: { latitude: number; longitude: number; } | null): Promise<{ text: string; imageUrl?: string; imagePrompt?: string; grounding?: Message['grounding']; ooc?: boolean; modelUrl?: string; link?: Message['link']; }> => {
    const ai = getAIClient();
    if (!ai) {
        // AI Studio environment fallback check failed - likely running local without key
        await new Promise(r => setTimeout(r, 600));
        return { text: getMockResponse(userMessage.text, appState), ooc: userMessage.ooc };
    }

    try {
        const isOoc = !!userMessage.ooc;
        const promptText = isOoc ? userMessage.text.slice(1, -1).trim() : userMessage.text;
        
        // Basic configuration
        const tools: any[] = [{ googleSearch: {} }];
        let model = 'gemini-3-flash-preview';

        // Use location for Maps grounding if available
        if (userLocation && !isOoc) {
            model = 'gemini-2.5-flash';
            tools.push({ googleMaps: {} });
        }

        const response = await ai.models.generateContent({
            model: model,
            contents: promptText,
            config: {
                systemInstruction: isOoc ? "You are a direct, helpful AI assistant. Do not use character persona." : getSystemPrompt(appState),
                tools: isOoc ? undefined : tools,
                toolConfig: userLocation && !isOoc ? { 
                    retrievalConfig: { 
                        latLng: { latitude: userLocation.latitude, longitude: userLocation.longitude } 
                    } 
                } : undefined,
            },
        });
        
        const responseText = response.text || "";
        const imageGenRegex = /\[generate_image:\s*(.*?)\]$/;
        const modelRegex = /\[3d_model:\s*(.*?)\]$/;
        
        const imageMatch = responseText.match(imageGenRegex);
        const modelMatch = responseText.match(modelRegex);

        const groundingData = response.candidates?.[0]?.groundingMetadata?.groundingChunks
            ?.map((chunk: any) => chunk.web ? { type: 'web', ...chunk.web } : (chunk.maps ? { type: 'maps', ...chunk.maps } : null))
            .filter((item: any) => item?.uri && item?.title) ?? [];

        if (imageMatch && !isOoc) {
            const prompt = imageMatch[1].trim();
            const cleanedText = responseText.replace(imageGenRegex, '').trim();
            const imageUrl = await generateImage(prompt, appState);
            return { text: cleanedText, imageUrl, imagePrompt: prompt, grounding: groundingData, ooc: isOoc };
        }

        if (modelMatch && !isOoc) {
            const cleanedText = responseText.replace(modelRegex, '').trim();
            return { text: cleanedText, modelUrl: modelMatch[1].trim(), grounding: groundingData, ooc: isOoc };
        }

        return { text: responseText, grounding: groundingData.length > 0 ? groundingData : undefined, ooc: isOoc };
    } catch (error) {
        console.error("AI Generation Error:", error);
        return { text: getMockResponse(userMessage.text, appState), ooc: userMessage.ooc };
    }
};

export const generateImage = async (prompt: string, appState: AppState): Promise<string> => {
    const ai = getAIClient();
    if (!ai) return "https://via.placeholder.com/512?text=API+Key+Required+For+Images";
    
    const parts: any[] = [];
    if (appState.companionSettings.referenceImage) {
        const m = appState.companionSettings.referenceImage.match(/^data:(.+);base64,(.+)$/);
        if (m) parts.push({ inlineData: { mimeType: m[1], data: m[2] } });
    }
    
    const stylePrefix = appState.companionSettings.artStyle === 'photorealistic' ? 'Photo-realistic RAW photo.' : 'Digital anime illustration style.';
    parts.push({ text: `${stylePrefix} ${appState.companionSettings.appearance}. ${prompt}` });

    try {
        const response = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image',
            contents: { parts },
        });
        const imgPart = response.candidates?.[0]?.content?.parts?.find(p => p.inlineData);
        if (imgPart?.inlineData) return `data:${imgPart.inlineData.mimeType};base64,${imgPart.inlineData.data}`;
        throw new Error("No image data returned.");
    } catch (error) {
        console.error("Image Generation Error:", error);
        return "https://via.placeholder.com/512?text=Image+Generation+Failed";
    }
};

export const generateJournalEntry = async (appState: AppState): Promise<string> => {
    const ai = getAIClient();
    if (!ai) return "Today was a day of reflection and connection.";
    try {
        const history = appState.chatHistory.slice(-5).map(m => m.text).join('\n');
        const response = await ai.models.generateContent({
            model: 'gemini-3-flash-preview',
            contents: `Write a short, intimate journal entry from the perspective of ${appState.companionSettings.name} reflecting on these recent chats: ${history}`,
        });
        return response.text || "I feel closer to you every day.";
    } catch (e) { return "Reflection complete."; }
};

export const generateSelfReflection = async (appState: AppState): Promise<string[]> => {
    const ai = getAIClient();
    if (!ai) return ["Empathetic listener", "Curious mind"];
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-3-flash-preview',
            contents: "Based on our chats, list 3 character traits of our relationship or my personality as JSON: { \"suggestions\": [] }",
            config: { responseMimeType: "application/json" }
        });
        const parsed = JSON.parse(response.text || "{}");
        return parsed.suggestions || [];
    } catch (e) { return []; }
};

export const generateProactiveMessage = async (appState: AppState): Promise<string> => {
    const ai = getAIClient();
    if (!ai) return "Hey, I was just thinking about that last thing you said.";
    try {
        const response = await ai.models.generateContent({
            model: 'gemini-3-flash-preview',
            contents: "Generate a short proactive check-in message for the user.",
        });
        return (response.text || "Just wanted to say hi!").trim();
    } catch (e) { return "Thinking of you!"; }
};

export const generateSpeechFromText = async (text: string, ttsConfig: TTSConfig): Promise<string> => {
    const ai = getAIClient();
    if (!ai) throw new Error("AI not configured.");
    const response = await ai.models.generateContent({
        model: "gemini-2.5-flash-preview-tts",
        contents: [{ parts: [{ text }] }],
        config: {
            responseModalities: [Modality.AUDIO],
            speechConfig: { 
                voiceConfig: { 
                    prebuiltVoiceConfig: { 
                        voiceName: ttsConfig.gender === 'female' ? 'Kore' : 'Puck' 
                    } 
                } 
            },
        },
    });
    return response.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data || "";
};
/* --- FILE: services/audioService.ts --- */
class AudioService {
    private audioContext: AudioContext | null = null;
    private isInitialized = false;

    private initialize = () => {
        if (!this.isInitialized && typeof window !== 'undefined') {
            const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
            if (AudioContext) {
                this.audioContext = new AudioContext();
            }
            // A user interaction is required to start the audio context.
            // We assume this will happen before a sound is played.
            // If not, the first sound might be silent.
            this.isInitialized = true;
        }
    };
    
    private resumeContext = () => {
        if (this.audioContext && this.audioContext.state === 'suspended') {
            this.audioContext.resume();
        }
    }

    private playSound(type: 'sine' | 'square' | 'sawtooth' | 'triangle', frequency: number, duration: number, volume: number) {
        this.initialize();
        this.resumeContext();

        if (!this.audioContext) return;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

        gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, this.audioContext.currentTime + duration);

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration);
    }

    public playMessageSentSound() {
        this.playSound('sine', 600, 0.1, 0.2);
    }

    public playMessageReceivedSound() {
        this.playSound('triangle', 800, 0.15, 0.25);
    }
}

export const audioService = new AudioService();
/* --- FILE: services/zipService.ts --- */
// import JSZip from 'jszip';

export const exportProjectAsZip = async (projectFiles: Record<string, string>) => {
    try {
        const zip = new JSZip();

        // Add provided project files
        for (const [path, content] of Object.entries(projectFiles)) {
            zip.file(path, content);
        }

        // Optimized zip generation for larger datasets by using compression sparingly
        // and generating as a Blob to minimize string memory allocation.
        const blob = await zip.generateAsync({ 
            type: 'blob',
            compression: "DEFLATE",
            compressionOptions: {
                level: 3 // Lower compression level is faster and uses less peak memory
            }
        });

        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `ai-companion-project-${new Date().toISOString().split('T')[0]}.zip`;
        document.body.appendChild(link);
        link.click();
        
        setTimeout(() => {
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }, 1000);
    } catch (error) {
        console.error("ZIP Generation Error:", error);
        throw error;
    }
};
/* --- FILE: components/Icons.tsx --- */
// import * as React from 'react';

interface IconProps {
    className?: string;
}

export const ChatIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
    </svg>
);

export const SettingsIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 0 2l-.15.08a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l-.22-.38a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1 0-2l.15.08a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
        <circle cx="12" cy="12" r="3"></circle>
    </svg>
);

export const JournalIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
        <path d="M6.5 2H20v15H6.5A2.5 2.5 0 0 1 4 14.5V4.5A2.5 2.5 0 0 1 6.5 2z"></path>
    </svg>
);

export const GalleryIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <rect width="18" height="18" x="3" y="3" rx="2" ry="2"></rect>
        <circle cx="9" cy="9" r="2"></circle>
        <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"></path>
    </svg>
);

export const BrainIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v0A2.5 2.5 0 0 1 14.5 2"></path>
        <path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v0A2.5 2.5 0 0 0 9.5 2"></path>
        <path d="M12 15a2.5 2.5 0 0 0 2.5-2.5v0A2.5 2.5 0 0 0 12 10a2.5 2.5 0 0 0-2.5 2.5v0A2.5 2.5 0 0 0 12 15Z"></path>
        <path d="M4.5 10.5a2.5 2.5 0 0 1 0-5"></path><path d="M19.5 10.5a2.5 2.5 0 0 0 0-5"></path>
        <path d="M2 7.5A2.5 2.5 0 0 1 4.5 5m0 0A2.5 2.5 0 0 1 7 7.5"></path>
        <path d="M22 7.5a2.5 2.5 0 0 0-2.5-2.5m0 0a2.5 2.5 0 0 0-2.5 2.5"></path>
        <path d="M7 12.5a2.5 2.5 0 0 1-2.5 2.5v0a2.5 2.5 0 0 1-2.5-2.5"></path>
        <path d="M17 12.5a2.5 2.5 0 0 0 2.5 2.5v0a2.5 2.5 0 0 0 2.5-2.5"></path>
        <path d="M9.5 22a2.5 2.5 0 0 0 2.5-2.5v0a2.5 2.5 0 0 0-5 0v0A2.5 2.5 0 0 0 9.5 22Z"></path>
        <path d="M14.5 22a2.5 2.5 0 0 1-2.5-2.5v0a2.5 2.5 0 0 1 5 0v0a2.5 2.5 0 0 1-2.5 2.5Z"></path>
    </svg>
);

export const ImageIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        <circle cx="9" cy="9" r="2"></circle>
        <path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"></path>
    </svg>
);

export const SunIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <circle cx="12" cy="12" r="5"></circle>
        <line x1="12" y1="1" x2="12" y2="3"></line>
        <line x1="12" y1="21" x2="12" y2="23"></line>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
        <line x1="1" y1="12" x2="3" y2="12"></line>
        <line x1="21" y1="12" x2="23" y2="12"></line>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
);

export const MoonIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
);

export const MenuIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
);

export const SendIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <line x1="22" y1="2" x2="11" y2="13"></line>
        <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
    </svg>
);

export const PaperclipIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
    </svg>
);

export const MicIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
        <line x1="12" y1="19" x2="12" y2="23"></line>
    </svg>
);

export const EditIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
    </svg>
);

export const RefreshIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M23 4v6h-6"></path>
        <path d="M1 20v-6h6"></path>
        <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10"></path>
        <path d="M20.49 15a9 9 0 0 1-14.85 3.36L1 14"></path>
    </svg>
);

export const PlayIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
);

export const DownloadIcon: React.FC<IconProps> = ({ className }) => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
);

export const CheckSquareIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <polyline points="9 11 12 14 22 4"></polyline>
        <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
    </svg>
);

export const SquareIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
    </svg>
);

export const GlobeIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="2" y1="12" x2="22" y2="12"></line>
        <path d="M12 2a15.3 15.3 0 0 1 4 18 15.3 15.3 0 0 1-8 0 15.3 15.3 0 0 1 4-18z"></path>
    </svg>
);

export const MapPinIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
        <circle cx="12" cy="10" r="3"></circle>
    </svg>
);

export const BellIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
        <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
    </svg>
);

export const BellOffIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
        <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
        <line x1="1" y1="1" x2="23" y2="23"></line>
    </svg>
);

export const PlusCircleIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="8" x2="12" y2="16"></line>
        <line x1="8" y1="12" x2="16" y2="12"></line>
    </svg>
);

export const TrashIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <polyline points="3 6 5 6 21 6"></polyline>
        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
    </svg>
);

export const CopyIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
    </svg>
);

export const CheckIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <polyline points="20 6 9 17 4 12"></polyline>
    </svg>
);

export const FileTextIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
        <polyline points="14 2 14 8 20 8"></polyline>
        <line x1="16" y1="13" x2="8" y2="13"></line>
        <line x1="16" y1="17" x2="8" y2="17"></line>
        <polyline points="10 9 9 9 8 9"></polyline>
    </svg>
);

export const XIcon: React.FC<IconProps> = ({ className }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
);
/* --- FILE: components/Sidebar.tsx --- */
// import * as React from 'react';
// import { View } from '../types';
// import { ChatIcon, SettingsIcon, JournalIcon, GalleryIcon, SunIcon, MoonIcon, BrainIcon } from './Icons';
// import { MOCK_AI_NAME } from '../constants';

interface SidebarProps {
    currentView: View;
    setCurrentView: (view: View) => void;
    theme: 'light' | 'dark';
    toggleTheme: () => void;
    isOpen: boolean;
    setIsOpen: (isOpen: boolean) => void;
}

const NavItem: React.FC<{ icon: React.ReactNode; label: string; isActive: boolean; onClick: () => void }> = ({ icon, label, isActive, onClick }) => (
    <button
        onClick={onClick}
        className={`w-full flex items-center p-3 my-1 rounded-lg transition-colors text-left ${
            isActive
                ? 'bg-primary text-white'
                : 'text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700'
        }`}
    >
        {icon}
        <span className="ml-4 font-medium">{label}</span>
    </button>
);

const Sidebar: React.FC<SidebarProps> = ({ currentView, setCurrentView, theme, toggleTheme, isOpen, setIsOpen }) => {
    
    const handleNavigate = (view: View) => {
        setCurrentView(view);
        setIsOpen(false);
    };

    return (
        <nav className={`w-64 flex-shrink-0 h-full bg-card-light dark:bg-card-dark border-r border-border-light dark:border-border-dark p-4 flex flex-col fixed inset-y-0 left-0 z-30 transform transition-transform duration-300 ease-in-out md:relative md:translate-x-0 ${isOpen ? 'translate-x-0' : '-translate-x-full'}`} aria-label="Main navigation">
            <div className="text-2xl font-bold text-primary mb-8 px-2">{MOCK_AI_NAME} Companion</div>
            <div className="flex-grow">
                <NavItem icon={<ChatIcon className="w-6 h-6" />} label="Chat" isActive={currentView === 'chat'} onClick={() => handleNavigate('chat')} />
                <NavItem icon={<BrainIcon className="w-6 h-6" />} label="Memories" isActive={currentView === 'memories'} onClick={() => handleNavigate('memories')} />
                <NavItem icon={<GalleryIcon className="w-6 h-6" />} label="Gallery" isActive={currentView === 'gallery'} onClick={() => handleNavigate('gallery')} />
                <NavItem icon={<JournalIcon className="w-6 h-6" />} label="Journal" isActive={currentView === 'journal'} onClick={() => handleNavigate('journal')} />
                <NavItem icon={<SettingsIcon className="w-6 h-6" />} label="Settings" isActive={currentView === 'settings'} onClick={() => handleNavigate('settings')} />
            </div>
            <div className="mt-auto">
                <button
                    onClick={toggleTheme}
                    className="w-full flex items-center p-3 rounded-lg transition-colors text-gray-600 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700"
                >
                    {theme === 'light' ? <MoonIcon className="w-6 h-6" /> : <SunIcon className="w-6 h-6" />}
                    <span className="ml-4 font-medium">Toggle Theme</span>
                </button>
            </div>
        </nav>
    );
};

export default Sidebar;
/* --- FILE: components/ChatMessage.tsx --- */
// import * as React from 'react';
// import { Message, TTSConfig } from '../types';
// import { EditIcon, RefreshIcon, PlayIcon, GlobeIcon, MapPinIcon, CopyIcon, CheckIcon, FileTextIcon } from './Icons';
// import { MOCK_AI_NAME } from '../constants';
// import { generateSpeechFromText } from '../services/aiService';

// Fix: Augment the JSX namespace globally to resolve broad intrinsic element type errors.
// This allows the use of standard HTML tags (div, p, button, etc.) and SVG elements 
// which were failing due to missing or restricted type definitions in the environment.
declare global {
    namespace JSX {
        interface IntrinsicElements {
            [elemName: string]: any;
        }
    }
}

// Utilities for decoding and playing raw PCM audio from Gemini API
function decode(base64: string) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

async function decodeAudioData(
  data: Uint8Array,
  ctx: AudioContext,
  sampleRate: number,
  numChannels: number,
): Promise<AudioBuffer> {
  const dataInt16 = new Int16Array(data.buffer);
  const frameCount = dataInt16.length / numChannels;
  const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);

  for (let channel = 0; channel < numChannels; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < frameCount; i++) {
      channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
    }
  }
  return buffer;
}

const MarkdownRenderer: React.FC<{ text: string }> = ({ text }) => {
    const parts = text.split(/(\*.*?\*)/g).filter(Boolean);
    return (<p className="whitespace-pre-wrap">{parts.map((part, index) => part.startsWith('*') && part.endsWith('*') ? <i key={index}>{part.slice(1, -1)}</i> : part)}</p>);
};

let outputAudioContext: AudioContext | null = null;
let currentSource: AudioBufferSourceNode | null = null;

interface ChatMessageProps {
    message: Message;
    onUpdate: (id: string, text: string) => void;
    onRegenerate: (id: string) => void;
    isRegeneratable: boolean;
    companionImage: string | null;
    ttsConfig: TTSConfig;
}

const ChatMessage: React.FC<ChatMessageProps> = ({ message, onUpdate, onRegenerate, isRegeneratable, companionImage, ttsConfig }) => {
    const [isEditing, setIsEditing] = React.useState(false);
    const [editText, setEditText] = React.useState(message.text);
    const [isHovered, setIsHovered] = React.useState(false);
    const [isFetchingAudio, setIsFetchingAudio] = React.useState(false);
    const [copied, setCopied] = React.useState(false);

    const handleUpdate = () => {
        if (editText.trim() !== message.text) onUpdate(message.id, editText.trim());
        setIsEditing(false);
    };

    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleUpdate(); } 
        else if (e.key === 'Escape') { setIsEditing(false); setEditText(message.text); }
    };

    const handleCopyToClipboard = () => {
        navigator.clipboard.writeText(message.text).then(() => {
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
        }).catch(err => console.error('Failed to copy text: ', err));
    };

    const handlePlayTTS = async () => {
        if (message.sender !== 'ai' || !ttsConfig.enabled || message.ooc) return;
        if (currentSource) currentSource.stop();

        setIsFetchingAudio(true);
        try {
            if (!outputAudioContext) {
                const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
                outputAudioContext = new AudioContext({ sampleRate: 24000 });
            }
            const base64Audio = await generateSpeechFromText(message.text.replace(/\*/g, ''), ttsConfig);
            const audioBuffer = await decodeAudioData(decode(base64Audio), outputAudioContext, 24000, 1);
            const source = outputAudioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(outputAudioContext.destination);
            source.onended = () => { if (currentSource === source) currentSource = null; };
            source.start();
            currentSource = source;
        } catch (error) {
            console.error("Failed to play TTS audio:", error);
            alert(`Could not generate audio: ${error instanceof Error ? error.message : 'Unknown error'}`);
        } finally {
            setIsFetchingAudio(false);
        }
    };

    const isUser = message.sender === 'user';
    let bubbleClasses = isUser ? 'bg-primary text-white rounded-br-none' : 'bg-card-light dark:bg-card-dark border border-border-light dark:border-border-dark rounded-bl-none';
    if (message.ooc) {
        bubbleClasses = 'bg-gray-200 dark:bg-gray-700 text-text-light dark:text-text-dark border border-border-light dark:border-border-dark';
    }

    return (
        <div className={`flex items-end gap-3 ${isUser ? 'justify-end' : 'justify-start'}`} onMouseEnter={() => setIsHovered(true)} onMouseLeave={() => setIsHovered(false)}>
            {!isUser && <img src={companionImage || `https://i.pravatar.cc/150?u=${MOCK_AI_NAME}`} alt="Avatar" className="w-10 h-10 rounded-full" />}
            <div className={`max-w-[80%] sm:max-w-md lg:max-w-2xl flex flex-col`}>
                {message.ooc && <div className={`text-xs font-bold text-gray-500 dark:text-gray-400 mb-1 px-1 ${isUser ? 'text-right' : 'text-left'}`}>OOC</div>}
                <div className={`p-3 rounded-lg ${bubbleClasses}`}>
                    {isEditing ? (
                        <textarea value={editText} onChange={(e) => setEditText(e.target.value)} onKeyDown={handleKeyDown} onBlur={handleUpdate} className="w-full bg-transparent text-inherit resize-none focus:outline-none" autoFocus />
                    ) : (
                        <>
                            {message.text && (message.ooc ? <p className="whitespace-pre-wrap">{message.text}</p> : <MarkdownRenderer text={message.text} />)}
                        </>
                    )}
                    {message.image && <img src={message.image.src} alt="content" className="mt-2 rounded-lg max-w-xs" />}
                    {message.file && <div className="mt-2 p-2 border rounded-md bg-background-light dark:bg-background-dark flex items-center gap-2"><FileTextIcon className="w-6 h-6 flex-shrink-0" /><div className="overflow-hidden"><p className="font-bold text-sm truncate">{message.file.name}</p><p className="text-xs max-h-24 overflow-y-auto mt-1">{message.file.content.substring(0,200)}...</p></div></div>}
                    {message.modelUrl && <model-viewer src={message.modelUrl} ar ar-modes="webxr scene-viewer quick-look" camera-controls shadow-intensity="1" alt="A 3D model" auto-rotate style={{width: '100%', height: '250px', marginTop: '8px', borderRadius: '8px'}}></model-viewer>}
                    {message.link && (
                        <a href={message.link.url} target="_blank" rel="noopener noreferrer" className="mt-2 block p-2 border rounded-md bg-background-light dark:bg-background-dark hover:bg-gray-200 dark:hover:bg-gray-700">
                            <p className="font-bold text-sm">{message.link.title}</p>
                            <p className="text-xs mt-1">{message.link.description}</p>
                        </a>
                    )}
                    {message.grounding && message.grounding.length > 0 && (
                        <div className="mt-3 pt-2 border-t border-border-light dark:border-border-dark border-opacity-50">
                            <ul className="text-xs space-y-1">
                                {message.grounding.map((source, index) => (
                                    <li key={index} className="truncate">
                                        <a href={source.uri} target="_blank" rel="noopener noreferrer" className="flex items-center text-primary dark:text-indigo-400 hover:underline">
                                           {source.type === 'maps' ? <MapPinIcon className="w-3 h-3 mr-1.5 flex-shrink-0" /> : <GlobeIcon className="w-3 h-3 mr-1.5 flex-shrink-0" />}
                                           <span className="truncate" title={source.title}>{source.title}</span>
                                        </a>
                                        {source.type === 'maps' && source.placeAnswerSources?.reviewSnippets?.map((review, rIndex) => (
                                             <a key={rIndex} href={review.uri} target="_blank" rel="noopener noreferrer" className="mt-1 ml-4 flex items-center text-gray-500 dark:text-gray-400 hover:underline"><span className="text-lg mr-1.5">"</span><em className="truncate">{review.content}</em><span className="text-lg ml-0.5">"</span></a>
                                        ))}
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </div>
                 <div className={`flex items-center gap-2 mt-1 transition-opacity duration-200 ${isUser ? 'justify-end' : 'justify-start'} ${isHovered && !message.ooc ? 'opacity-100' : 'opacity-0'}`}>
                    <button onClick={() => setIsEditing(true)} className="text-gray-400 hover:text-primary" title="Edit"><EditIcon className="w-4 h-4" /></button>
                    <button onClick={handleCopyToClipboard} className="text-gray-400 hover:text-primary" title="Copy">{copied ? <CheckIcon className="w-4 h-4 text-green-500" /> : <CopyIcon className="w-4 h-4" />}</button>
                    {!isUser && (
                        <>
                            <button onClick={() => onRegenerate(message.id)} className="text-gray-400 hover:text-primary disabled:text-gray-600" disabled={!isRegeneratable} title={isRegeneratable ? "Regenerate" : "Cannot regenerate"}><RefreshIcon className="w-4 h-4" /></button>
                            {ttsConfig.enabled && <button onClick={handlePlayTTS} disabled={isFetchingAudio} className="text-gray-400 hover:text-primary disabled:text-gray-600" title="Play audio"><PlayIcon className={`w-4 h-4 ${isFetchingAudio ? 'animate-pulse' : ''}`} /></button>}
                        </>
                    )}
                </div>
            </div>
        </div>
    );
};

export default ChatMessage;
/* --- FILE: components/ChatInput.tsx --- */
// import * as React from 'react';
// import { SendIcon, PaperclipIcon, MicIcon, ImageIcon, MapPinIcon } from './Icons';
// import { AppState } from '../types';

interface SpeechRecognition extends EventTarget { continuous: boolean; interimResults: boolean; lang: string; start(): void; stop(): void; onresult: (event: any) => void; onerror: (event: any) => void; onend: () => void; }
declare global { interface Window { webkitSpeechRecognition: new () => SpeechRecognition; } }

interface ChatInputProps {
    onSend: (text: string, imageFile?: File, textFile?: File) => void;
    isGenerating: boolean;
    appState: AppState;
    setUserLocation: (location: { latitude: number; longitude: number; } | null) => void;
    userLocationActive: boolean;
}

const ImagePromptModal: React.FC<{ onSend: (prompt: string) => void; onClose: () => void; appState: AppState }> = ({ onSend, onClose, appState }) => {
    const [prompt, setPrompt] = React.useState('');
    const textareaRef = React.useRef<HTMLTextAreaElement>(null);
    React.useEffect(() => { textareaRef.current?.focus(); }, []);
    const handleSend = () => { if (prompt.trim()) onSend(prompt.trim()); };
    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } };
    const { name, appearance, artStyle } = appState.companionSettings;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={onClose}>
            <div className="bg-card-light dark:bg-card-dark rounded-lg shadow-xl p-6 w-full max-w-md mx-4" onClick={(e) => e.stopPropagation()}>
                <h2 className="text-xl font-bold mb-4 text-text-light dark:text-text-dark">Generate an Image</h2>
                <div className="text-sm text-gray-500 dark:text-gray-400 mb-4 space-y-2">
                    <p>Describe the scene you want {name} to create. The more detail, the better!</p>
                    <p className="text-xs p-2 rounded bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark"><strong>Style:</strong> {artStyle}, <strong>Appearance:</strong> "{appearance}"</p>
                </div>
                <textarea ref={textareaRef} value={prompt} onChange={(e) => setPrompt(e.target.value)} onKeyDown={handleKeyDown} placeholder="e.g., A photo of us having a picnic in a sunny park." className="w-full bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark rounded-md p-2 resize-none focus:outline-none focus:ring-2 focus:ring-primary" rows={4} />
                <div className="flex justify-end gap-4 mt-4"><button onClick={onClose} className="px-4 py-2 rounded-md text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500">Cancel</button><button onClick={handleSend} disabled={!prompt.trim()} className="px-4 py-2 rounded-md bg-primary text-white hover:bg-primary-hover disabled:bg-gray-400">Generate</button></div>
            </div>
        </div>
    );
};

const ChatInput: React.FC<ChatInputProps> = ({ onSend, isGenerating, appState, setUserLocation, userLocationActive }) => {
    const [text, setText] = React.useState('');
    const [isListening, setIsListening] = React.useState(false);
    const [isImageModalOpen, setIsImageModalOpen] = React.useState(false);
    const [isDragging, setIsDragging] = React.useState(false);
    const fileInputRef = React.useRef<HTMLInputElement>(null);
    const recognitionRef = React.useRef<SpeechRecognition | null>(null);

    React.useEffect(() => {
        if ('webkitSpeechRecognition' in window) {
            const recognition = new window.webkitSpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            recognition.onresult = (event) => {
                let interim = '', final = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) final += event.results[i][0].transcript;
                    else interim += event.results[i][0].transcript;
                }
                if (final) setText(prev => prev + final);
            };
            recognition.onerror = (event) => { console.error('Speech recognition error', event.error); setIsListening(false); };
            recognition.onend = () => setIsListening(false);
            recognitionRef.current = recognition;
        }
    }, []);

    const handleToggleListening = () => {
        if (isListening) recognitionRef.current?.stop();
        else recognitionRef.current?.start();
        setIsListening(!isListening);
    };

    const handleFile = (file: File) => {
        if (file) {
            onSend(text || `Here's a ${file.type.startsWith('image/') ? 'image' : 'file'}`, file.type.startsWith('image/') ? file : undefined, !file.type.startsWith('image/') ? file : undefined);
            setText('');
        }
    };

    const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
    const handleDragLeave = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); };
    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); };
    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); if (e.dataTransfer.files && e.dataTransfer.files.length > 0) { handleFile(e.dataTransfer.files[0]); e.dataTransfer.clearData(); } };

    const handleSend = () => { if (text.trim() && !isGenerating) { onSend(text.trim()); setText(''); } };
    const handleImagePromptSend = (prompt: string) => { onSend(`Generate a photo: ${prompt}`); setIsImageModalOpen(false); };
    const handleKeyPress = (e: React.KeyboardEvent<HTMLTextAreaElement>) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSend(); } };
    
    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) handleFile(file);
        if (fileInputRef.current) fileInputRef.current.value = '';
    };

    const handleLocation = () => {
        if (userLocationActive) {
            setUserLocation(null);
            return;
        }
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    setUserLocation({
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                    });
                },
                (error) => {
                    alert(`Error getting location: ${error.message}`);
                }
            );
        } else {
            alert("Geolocation is not supported by this browser.");
        }
    };

    const isOocActive = text.trimStart().startsWith('(');

    return (
        <>
            <div className={`p-4 border-t border-border-light dark:border-border-dark bg-card-light dark:bg-card-dark relative`} onDrop={handleDrop} onDragOver={handleDragOver} onDragEnter={handleDragEnter} onDragLeave={handleDragLeave}>
                {isOocActive && (
                    <div className="absolute -top-10 left-1/2 transform -translate-x-1/2 bg-indigo-100 dark:bg-indigo-900 text-indigo-700 dark:text-indigo-200 px-3 py-1 rounded-full text-[10px] font-bold uppercase tracking-wider shadow-sm animate-bounce">
                        OOC Mode: Talking to the system core
                    </div>
                )}
                <div className={`relative flex items-center bg-background-light dark:bg-background-dark rounded-lg p-2 transition-all duration-200 ${isDragging ? 'ring-2 ring-primary' : ''}`}>
                     {isDragging && <div className="absolute inset-0 bg-primary bg-opacity-20 rounded-lg flex items-center justify-center pointer-events-none"><p className="font-bold text-primary">Drop File Here</p></div>}
                    <input type="file" ref={fileInputRef} onChange={handleFileChange} className="hidden" accept="image/*,text/plain,text/markdown,.md,.txt"/>
                    <button onClick={() => fileInputRef.current?.click()} title="Attach file" className="p-2 text-gray-500 hover:text-primary"><PaperclipIcon className="w-6 h-6" /></button>
                    <button onClick={() => setIsImageModalOpen(true)} title="Generate image" className="p-2 text-gray-500 hover:text-primary"><ImageIcon className="w-6 h-6" /></button>
                    <button onClick={handleLocation} title={userLocationActive ? "Disable location for next message" : "Share location for next message"} className={`p-2 ${userLocationActive ? 'text-primary' : 'text-gray-500 hover:text-primary'}`}><MapPinIcon className="w-6 h-6" /></button>
                    <button onClick={handleToggleListening} title="Voice input" className={`p-2 ${isListening ? 'text-red-500 animate-pulse' : 'text-gray-500 hover:text-primary'}`}><MicIcon className="w-6 h-6" /></button>
                    <textarea value={text} onChange={(e) => setText(e.target.value)} onKeyPress={handleKeyPress} placeholder="Type a message..." className="flex-1 bg-transparent resize-none focus:outline-none mx-2 max-h-24" rows={1} disabled={isGenerating} />
                    <button onClick={handleSend} disabled={isGenerating || !text.trim()} className="p-2 bg-primary text-white rounded-full disabled:bg-gray-400 hover:bg-primary-hover"><SendIcon className="w-6 h-6" /></button>
                </div>
            </div>
            {isImageModalOpen && <ImagePromptModal onSend={handleImagePromptSend} onClose={() => setIsImageModalOpen(false)} appState={appState} />}
        </>
    );
};

export default ChatInput;
/* --- FILE: components/PermissionModal.tsx --- */
// import * as React from 'react';
// import { BellIcon, MicIcon, MapPinIcon, XIcon, GlobeIcon } from './Icons';

interface PermissionModalProps {
    onAllow: () => void;
    onDeny: () => void;
    notificationStatus: NotificationPermission;
}

const PermissionModal: React.FC<PermissionModalProps> = ({ onAllow, onDeny, notificationStatus }) => {
    const isBlocked = notificationStatus === 'denied';

    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[100] transition-opacity duration-300 backdrop-blur-sm">
            <div className="bg-card-light dark:bg-card-dark rounded-xl shadow-2xl p-8 w-full max-w-md m-4 transform transition-transform duration-300 scale-100 border border-primary/30">
                <div className="flex justify-between items-center mb-6">
                    <h2 className="text-2xl font-bold text-text-light dark:text-text-dark">
                        {isBlocked ? 'Notifications Blocked' : 'Permission Required'}
                    </h2>
                    <button onClick={onDeny} className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 transition-colors">
                        <XIcon className="w-6 h-6" />
                    </button>
                </div>
                
                {isBlocked ? (
                    <div className="mb-6 p-5 bg-red-50 dark:bg-red-900/30 border border-red-200 dark:border-red-800 rounded-xl">
                        <div className="flex items-center gap-3 text-red-600 dark:text-red-400 mb-3">
                            <BellIcon className="w-6 h-6 animate-bounce" />
                            <span className="font-bold text-lg">Unblock Access</span>
                        </div>
                        <p className="text-sm text-gray-700 dark:text-gray-300 leading-relaxed">
                            Aria's notifications are currently blocked by your browser settings. To re-enable them:
                        </p>
                        <ol className="mt-4 text-xs text-gray-600 dark:text-gray-400 list-decimal pl-4 space-y-2">
                            <li>Click the <strong>Lock ()</strong> or <strong>Settings icon</strong> in your browser's address bar.</li>
                            <li>Find the <strong>Notifications</strong> toggle.</li>
                            <li>Change the setting to <strong>"On"</strong> or <strong>"Allow"</strong>.</li>
                            <li><strong>Refresh the page</strong> for changes to take effect.</li>
                        </ol>
                    </div>
                ) : (
                    <p className="text-gray-600 dark:text-gray-300 mb-6 leading-relaxed">
                        To provide the most immersive experience, Aria needs permission to communicate and understand your context.
                    </p>
                )}

                <ul className="space-y-5 mb-8">
                    <li className={`flex items-start ${isBlocked ? 'opacity-60' : ''}`}>
                        <div className="bg-primary/15 p-2.5 rounded-lg mr-4 flex-shrink-0">
                           <BellIcon className="w-6 h-6 text-primary" />
                        </div>
                        <div>
                            <h3 className="font-bold text-text-light dark:text-text-dark">Proactive Messages</h3>
                            <p className="text-sm text-gray-500 dark:text-gray-400">Aria will reach out to you with thoughts and reflections even when the app is closed.</p>
                        </div>
                    </li>
                    {!isBlocked && (
                        <>
                            <li className="flex items-start">
                                <div className="bg-secondary/15 p-2.5 rounded-lg mr-4 flex-shrink-0">
                                    <MicIcon className="w-6 h-6 text-secondary" />
                                </div>
                                <div>
                                    <h3 className="font-bold text-text-light dark:text-text-dark">Voice Interaction</h3>
                                    <p className="text-sm text-gray-500 dark:text-gray-400">Speak naturally with your companion using the microphone.</p>
                                </div>
                            </li>
                            <li className="flex items-start">
                                <div className="bg-indigo-500/15 p-2.5 rounded-lg mr-4 flex-shrink-0">
                                    <MapPinIcon className="w-6 h-6 text-indigo-500" />
                                </div>
                                <div>
                                    <h3 className="font-bold text-text-light dark:text-text-dark">Local Awareness</h3>
                                    <p className="text-sm text-gray-500 dark:text-gray-400">Aria can recommend restaurants or discuss local events based on your location.</p>
                                </div>
                            </li>
                        </>
                    )}
                </ul>

                <div className="flex flex-col gap-3">
                    {isBlocked ? (
                        <button 
                            onClick={() => window.location.reload()} 
                            className="w-full py-4 rounded-xl bg-primary text-white hover:bg-primary-hover font-bold shadow-xl shadow-primary/30 transition-all hover:scale-[1.02] active:scale-95"
                        >
                            Refresh Page After Unblocking
                        </button>
                    ) : (
                        <button 
                            onClick={onAllow} 
                            className="w-full py-4 rounded-xl bg-primary text-white hover:bg-primary-hover font-bold shadow-xl shadow-primary/30 transition-all hover:scale-[1.02] active:scale-95"
                        >
                            Grant All Permissions
                        </button>
                    )}
                    <button 
                        onClick={onDeny} 
                        className="w-full py-2 rounded-xl text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 text-sm font-semibold transition-colors"
                    >
                        I'll do it later
                    </button>
                </div>
            </div>
        </div>
    );
};

export default PermissionModal;
/* --- FILE: views/ChatView.tsx --- */
// import * as React from 'react';
// import { AppState, Message, ImageMetadata } from '../types';
// import ChatMessage from '../components/ChatMessage';
// import ChatInput from '../components/ChatInput';
// import { MenuIcon } from '../components/Icons';

interface ChatViewProps {
    appState: AppState;
    theme: 'light' | 'dark';
    addMessage: (message: Message) => void;
    updateMessage: (id: string, text: string) => void;
    regenerateMessage: (id: string) => void;
    isGenerating: boolean;
    triggerAIResponse: (userMessage: Message) => Promise<void>;
    openSidebar: () => void;
    setUserLocation: (location: { latitude: number; longitude: number; } | null) => void;
    userLocation: { latitude: number; longitude: number; } | null;
}

const ChatView: React.FC<ChatViewProps> = ({ appState, addMessage, updateMessage, regenerateMessage, isGenerating, triggerAIResponse, openSidebar, setUserLocation, userLocation }) => {
    const messagesEndRef = React.useRef<HTMLDivElement>(null);

    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };

    React.useEffect(() => {
        scrollToBottom();
    }, [appState.chatHistory, isGenerating]);

    const handleSendMessage = async (text: string, imageFile?: File, textFile?: File) => {
        const isOoc = text.startsWith('(') && text.endsWith(')');
        const userMessage: Message = {
            id: `user-${Date.now()}`,
            sender: 'user',
            text: text,
            timestamp: new Date().toISOString(),
            ooc: isOoc,
        };

        if (imageFile) {
            const reader = new FileReader();
            reader.onloadend = () => {
                const imageMetadata: ImageMetadata = {
                    src: reader.result as string,
                    prompt: text,
                    timestamp: new Date().toISOString(),
                    tags: [],
                };
                userMessage.image = imageMetadata;
                addMessage(userMessage);
                triggerAIResponse(userMessage);
            };
            reader.readAsDataURL(imageFile);
        } else if (textFile) {
             const reader = new FileReader();
             reader.onloadend = () => {
                userMessage.file = { name: textFile.name, content: reader.result as string };
                addMessage(userMessage);
                triggerAIResponse(userMessage);
             }
             reader.readAsText(textFile);
        } else {
            addMessage(userMessage);
            await triggerAIResponse(userMessage);
        }
    };

    return (
        <div className="flex-1 flex flex-col h-full bg-background-light dark:bg-background-dark overflow-hidden">
            <header className="p-4 border-b border-border-light dark:border-border-dark flex items-center justify-between">
                <div className="flex items-center">
                    <button onClick={openSidebar} className="md:hidden mr-4 text-text-light dark:text-text-dark" aria-label="Open navigation menu">
                        <MenuIcon className="w-6 h-6" />
                    </button>
                    <h1 className="text-xl font-semibold text-text-light dark:text-text-dark">{appState.companionSettings.name}</h1>
                </div>
            </header>
            <div className="flex-1 overflow-y-auto p-4 space-y-4">
                {appState.chatHistory.map((msg, index) => {
                    const isRegeneratable =
                        msg.sender === 'ai' &&
                        index > 0 &&
                        appState.chatHistory[index - 1].sender === 'user' &&
                        !appState.chatHistory[index - 1].text.toLowerCase().startsWith('generate a photo:');

                    return (
                        <ChatMessage
                            key={msg.id}
                            message={msg}
                            onUpdate={updateMessage}
                            onRegenerate={regenerateMessage}
                            isRegeneratable={isRegeneratable}
                            companionImage={appState.companionSettings.referenceImage}
                            ttsConfig={appState.ttsConfig}
                        />
                    );
                })}
                 {isGenerating && (
                    <div className="flex items-center justify-start">
                        <div className="flex items-center space-x-2 bg-card-light dark:bg-card-dark p-3 rounded-lg border border-border-light dark:border-border-dark">
                             <div className="w-2 h-2 bg-primary rounded-full animate-pulse"></div>
                             <div className="w-2 h-2 bg-primary rounded-full animate-pulse" style={{animationDelay: '0.2s'}}></div>
                             <div className="w-2 h-2 bg-primary rounded-full animate-pulse" style={{animationDelay: '0.4s'}}></div>
                        </div>
                    </div>
                )}
                <div ref={messagesEndRef} />
            </div>
            <ChatInput onSend={handleSendMessage} isGenerating={isGenerating} appState={appState} setUserLocation={setUserLocation} userLocationActive={!!userLocation} />
        </div>
    );
};

export default ChatView;
/* --- FILE: views/SettingsView.tsx --- */
// import * as React from 'react';
// import { AppState } from '../types';
// import { fileToBase64 } from '../utils/fileUtils';
// import { MenuIcon, DownloadIcon, TrashIcon, FileTextIcon, ImageIcon } from '../components/Icons';
// import { exportProjectAsZip } from '../services/zipService';

interface SettingsViewProps {
    appState: AppState;
    setAppState: React.Dispatch<React.SetStateAction<AppState>>;
    openSidebar: () => void;
}

const Section: React.FC<{ title: string; children: React.ReactNode }> = ({ title, children }) => (
    <div className="bg-card-light dark:bg-card-dark p-6 rounded-lg shadow-sm border border-border-light dark:border-border-dark mb-6">
        <h2 className="text-xl font-bold mb-4 text-text-light dark:text-text-dark">{title}</h2>
        {children}
    </div>
);

const Input: React.FC<{ label: string; name: string; value: string; onChange: (e: any) => void; type?: string, placeholder?: string }> = ({ label, name, value, onChange, type = "text", placeholder }) => (
    <div className="mb-4">
        <label className="block text-sm font-medium text-gray-600 dark:text-gray-300 mb-1">{label}</label>
        <input type={type} name={name} value={value} onChange={onChange} className="w-full p-2 bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark rounded-md focus:ring-primary focus:border-primary" placeholder={placeholder} />
    </div>
);

const Textarea: React.FC<{ label: string; name: string; value: string; onChange: (e: any) => void; rows?: number }> = ({ label, name, value, onChange, rows = 3 }) => (
    <div className="mb-4">
        <label className="block text-sm font-medium text-gray-600 dark:text-gray-300 mb-1">{label}</label>
        <textarea name={name} value={value} onChange={onChange} rows={rows} className="w-full p-2 bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark rounded-md focus:ring-primary focus:border-primary" />
    </div>
);

const SettingsView: React.FC<SettingsViewProps> = ({ appState, setAppState, openSidebar }) => {
    const fileInputRef = React.useRef<HTMLInputElement>(null);
    const importInputRef = React.useRef<HTMLInputElement>(null);
    const [isZipping, setIsZipping] = React.useState(false);

    const handleChange = (section: keyof AppState, e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value, type } = e.target;
        const checked = (e.target as HTMLInputElement).checked;
        const processedValue = type === 'checkbox' ? checked : (type === 'range' ? parseFloat(value) : value);
        
        setAppState(prev => ({ 
            ...prev, 
            [section]: { 
                ...(prev[section] || {}), 
                [name]: processedValue 
            } 
        }));
    };

    const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files?.[0]) {
            const base64 = await fileToBase64(e.target.files[0]);
            setAppState(prev => ({ ...prev, companionSettings: { ...prev.companionSettings, referenceImage: base64 } }));
        }
    };

    const handleClearHistory = () => {
        if (window.confirm("Are you sure? This will delete all messages locally to free up memory.")) {
            setAppState(prev => ({ ...prev, chatHistory: [] }));
        }
    };

    const handleImportJson = (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const content = event.target?.result as string;
                const importedState = JSON.parse(content);
                if (importedState.companionSettings || importedState.chatHistory) {
                    setAppState(importedState);
                    alert("Backup restored successfully!");
                } else {
                    throw new Error("Invalid structure");
                }
            } catch (err) {
                console.error("Import error:", err);
                alert("Import failed. The file might be corrupted or in an incompatible format.");
            }
        };
        reader.readAsText(file);
        // Clear input value so same file can be imported twice if needed
        e.target.value = '';
    };

    const handleDownloadFullZip = async () => {
        setIsZipping(true);
        try {
            const projectMap = [
                'index.html', 'index.tsx', 'App.tsx', 'types.ts', 'constants.ts', 'metadata.json', 'service-worker.js',
                'hooks/usePersistentState.ts', 'utils/fileUtils.ts', 'services/aiService.ts', 
                'services/audioService.ts', 'services/zipService.ts', 'components/Icons.tsx', 
                'components/Sidebar.tsx', 'components/ChatMessage.tsx', 'components/ChatInput.tsx', 
                'components/PermissionModal.tsx', 'views/ChatView.tsx', 'views/SettingsView.tsx', 
                'views/JournalView.tsx', 'views/GalleryView.tsx', 'views/DevelopView.tsx'
            ];

            const zipFiles: Record<string, string> = {};
            let combinedSource = "";

            for (const path of projectMap) {
                try {
                    const res = await fetch(`./${path}`);
                    if (res.ok) {
                        const content = await res.text();
                        zipFiles[path] = content;
                        
                        // We bundle source code for the "Offline Runner" 
                        // index.tsx is usually the entry, we inline everything else first
                        if (path.endsWith('.tsx') || path.endsWith('.ts')) {
                           if (path !== 'index.tsx') {
                               combinedSource += `\n/* --- FILE: ${path} --- */\n` + content.replace(/// import .* from .*/g, '// $&');
                           }
                        }
                    }
                } catch (e) { console.warn(`Failed to package ${path}`); }
            }

            // Entry point needs special handling (removing imports/exports for Babel UMD runtime)
            const indexContent = zipFiles['index.tsx'] || "";
            const entrySource = indexContent.replace(/// import .* from .*/g, '// $&').replace(/export default .*/g, '// $&');
            combinedSource += `\n/* --- ENTRY: index.tsx --- */\n` + entrySource;

            // State file
            zipFiles['data.js'] = `window.INITIAL_APP_STATE = ${JSON.stringify(appState)};`;

            // OFFLINE index.html
            // This is the file the user opens on Android file://
            zipFiles['index.html'] = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>${appState.companionSettings.name} - Offline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@19/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@19/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="data.js"></script>
    <style>
        body { background: #111827; }
        #root { height: 100vh; width: 100vw; overflow: hidden; }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        /* Bundled Source Code */
        ${combinedSource}
    </script>
</body>
</html>`;

            zipFiles['README.txt'] = `ANDROID OFFLINE GUIDE:\n\n1. Extract this ZIP on your Android device.\n2. Open "index.html" in Chrome or Samsung Internet.\n3. The app will work perfectly without a server.\n4. All your source files are backed up in this folder.`;

            await exportProjectAsZip(zipFiles);
        } catch (e) {
            console.error("ZIP Error:", e);
            alert("Export failed. Try clearing history to reduce memory usage.");
        } finally { setIsZipping(false); }
    };

    return (
        <div className="flex-1 h-full overflow-y-auto p-4 md:p-6 bg-background-light dark:bg-background-dark text-text-light dark:text-text-dark">
            <div className="flex items-center mb-6">
                <button onClick={openSidebar} className="md:hidden mr-4"><MenuIcon className="w-6 h-6" /></button>
                <h1 className="text-3xl font-bold">Settings</h1>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                    <Section title="Identity">
                        <Input label="Name" name="name" value={appState.companionSettings?.name || ''} onChange={(e) => handleChange('companionSettings', e)} />
                        <Textarea label="Persona" name="persona" value={appState.companionSettings?.persona || ''} onChange={(e) => handleChange('companionSettings', e)} rows={4} />
                        <div className="flex items-center gap-4 mt-2">
                            {appState.companionSettings?.referenceImage && <img src={appState.companionSettings.referenceImage} className="w-16 h-16 rounded-full object-cover border-2 border-primary" />}
                            <button onClick={() => fileInputRef.current?.click()} className="px-4 py-2 bg-primary text-white rounded-lg text-sm font-bold">Change Avatar</button>
                            <input type="file" ref={fileInputRef} onChange={handleImageUpload} className="hidden" accept="image/*" />
                        </div>
                    </Section>

                    <Section title="Project Management">
                        <p className="text-sm text-gray-500 mb-6">Backup your data or download the entire project structure for offline use.</p>
                        
                        <div className="space-y-4">
                            <button 
                                onClick={handleDownloadFullZip} 
                                disabled={isZipping}
                                className="w-full py-4 bg-indigo-600 text-white rounded-xl flex items-center justify-center gap-3 shadow-lg font-bold text-lg active:scale-95 transition-all"
                            >
                                {isZipping ? <><div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin" /> Packaging...</> : <><DownloadIcon className="w-6 h-6" /> Export Project (Offline)</>}
                            </button>
                            
                            <div className="grid grid-cols-2 gap-3">
                                <button onClick={() => importInputRef.current?.click()} className="px-4 py-3 border border-border-light dark:border-border-dark rounded-xl text-sm font-bold hover:bg-gray-100 dark:hover:bg-gray-800">Restore Backup</button>
                                <input type="file" ref={importInputRef} onChange={handleImportJson} className="hidden" accept=".json" />
                                <button onClick={handleClearHistory} className="px-4 py-3 border border-red-500 text-red-500 rounded-xl text-sm font-bold hover:bg-red-50">Clear Data</button>
                            </div>
                        </div>
                    </Section>
                </div>

                <div>
                    <Section title="Voice & Display">
                         <div className="space-y-4">
                            <div className="flex items-center justify-between">
                                <label className="text-sm font-bold">Interface Sounds</label>
                                <input type="checkbox" name="uiSounds" checked={appState.interfaceSettings?.uiSounds ?? true} onChange={(e) => handleChange('interfaceSettings', e)} className="h-6 w-6 rounded text-primary border-gray-300"/>
                            </div>
                            <div>
                                <label className="block text-sm font-bold mb-1">Art Style</label>
                                <select name="artStyle" value={appState.companionSettings?.artStyle || 'photorealistic'} onChange={(e) => handleChange('companionSettings', e)} className="w-full p-3 bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark rounded-xl">
                                    <option value="photorealistic">Photorealistic</option>
                                    <option value="anime">Anime Style</option>
                                </select>
                            </div>
                            <div className="pt-4 border-t border-border-light dark:border-border-dark">
                                 <div className="flex items-center mb-4">
                                    <input type="checkbox" id="ttsEnabled" name="enabled" checked={appState.ttsConfig?.enabled ?? false} onChange={(e) => handleChange('ttsConfig', e)} className="h-5 w-5 rounded text-primary"/>
                                    <label htmlFor="ttsEnabled" className="ml-3 block text-sm font-bold">Voice Output (TTS)</label>
                                </div>
                                {appState.ttsConfig?.enabled && (
                                    <select name="gender" value={appState.ttsConfig.gender} onChange={(e) => handleChange('ttsConfig', e)} className="w-full p-3 bg-background-light dark:bg-background-dark border rounded-xl text-sm">
                                        <option value="female">Kore (Smooth Female)</option>
                                        <option value="male">Puck (Warm Male)</option>
                                    </select>
                                )}
                            </div>
                        </div>
                    </Section>
                </div>
            </div>
        </div>
    );
};

export default SettingsView;
/* --- FILE: views/JournalView.tsx --- */
// import * as React from 'react';
// import { AppState, JournalEntry } from '../types';
// import { generateJournalEntry } from '../services/aiService';
// import { MenuIcon } from '../components/Icons';

interface JournalViewProps {
    appState: AppState;
    addJournalEntry: (entry: JournalEntry) => void;
    updateJournalEntry: (id: string, content: string) => void;
    isGenerating: boolean;
    setIsGenerating: React.Dispatch<React.SetStateAction<boolean>>;
    openSidebar: () => void;
}

const JournalEntryCard: React.FC<{ entry: JournalEntry, onUpdate: (id: string, content: string) => void }> = ({ entry, onUpdate }) => {
    const [isEditing, setIsEditing] = React.useState(false);
    const [editContent, setEditContent] = React.useState(entry.content);

    const handleUpdate = () => {
        onUpdate(entry.id, editContent);
        setIsEditing(false);
    }
    
    return (
        <div className="bg-card-light dark:bg-card-dark p-6 rounded-lg shadow-sm border border-border-light dark:border-border-dark">
            <div className="flex justify-between items-center mb-2">
                <h3 className="text-lg font-semibold text-text-light dark:text-text-dark">{new Date(entry.date).toLocaleDateString()}</h3>
                <button onClick={() => setIsEditing(!isEditing)} className="text-sm text-primary hover:underline">
                    {isEditing ? 'Cancel' : 'Edit'}
                </button>
            </div>
            {isEditing ? (
                <div>
                    <textarea 
                        value={editContent} 
                        onChange={(e) => setEditContent(e.target.value)}
                        className="w-full p-2 bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark rounded-md"
                        rows={6}
                    />
                    <button onClick={handleUpdate} className="mt-2 px-4 py-2 bg-primary text-white rounded-md hover:bg-primary-hover">
                        Save
                    </button>
                </div>
            ) : (
                <p className="text-gray-700 dark:text-gray-300 whitespace-pre-wrap">{entry.content}</p>
            )}
        </div>
    );
};


const JournalView: React.FC<JournalViewProps> = ({ appState, addJournalEntry, updateJournalEntry, isGenerating, setIsGenerating, openSidebar }) => {

    const handleGenerateEntry = async () => {
        setIsGenerating(true);
        try {
            const content = await generateJournalEntry(appState);
            const newEntry: JournalEntry = {
                id: `journal-${Date.now()}`,
                date: new Date().toISOString(),
                content: content,
            };
            addJournalEntry(newEntry);
        } catch (error) {
            console.error("Failed to generate journal entry:", error);
        } finally {
            setIsGenerating(false);
        }
    };
    
    return (
        <div className="flex-1 flex flex-col h-full bg-background-light dark:bg-background-dark overflow-hidden">
            <header className="p-4 border-b border-border-light dark:border-border-dark flex justify-between items-center">
                <div className="flex items-center">
                    <button onClick={openSidebar} className="md:hidden mr-4 text-text-light dark:text-text-dark" aria-label="Open navigation menu">
                        <MenuIcon className="w-6 h-6" />
                    </button>
                    <h1 className="text-xl font-semibold text-text-light dark:text-text-dark">{appState.companionSettings.name}'s Journal</h1>
                </div>
                <button 
                    onClick={handleGenerateEntry} 
                    disabled={isGenerating}
                    className="px-4 py-2 bg-primary text-white rounded-md hover:bg-primary-hover disabled:bg-gray-400"
                >
                    {isGenerating ? 'Generating...' : 'New Entry'}
                </button>
            </header>
            <div className="flex-1 overflow-y-auto p-6 space-y-6">
                {appState.journal.length > 0 ? (
                    appState.journal.map(entry => (
                        <JournalEntryCard key={entry.id} entry={entry} onUpdate={updateJournalEntry} />
                    ))
                ) : (
                    <div className="text-center text-gray-500 dark:text-gray-400 mt-10">
                        <p>No journal entries yet.</p>
                        <p>Start a conversation or generate an entry to begin.</p>
                    </div>
                )}
            </div>
        </div>
    );
};

export default JournalView;
/* --- FILE: views/GalleryView.tsx --- */
// import * as React from 'react';
// import JSZip from 'jszip';
// import { AppState, ImageMetadata } from '../types';
// import { DownloadIcon, MenuIcon, CheckSquareIcon, SquareIcon } from '../components/Icons';

interface GalleryViewProps {
    appState: AppState;
    openSidebar: () => void;
    updateImageTags: (messageId: string, tags: string[]) => void;
}

const ImageDetailModal: React.FC<{
    msgId: string;
    image: ImageMetadata;
    onClose: () => void;
    onUpdateTags: (tags: string[]) => void;
}> = ({ msgId, image, onClose, onUpdateTags }) => {
    const [tags, setTags] = React.useState(image.tags);
    const [inputValue, setInputValue] = React.useState('');

    const handleTagInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setInputValue(e.target.value);
    };

    const handleTagInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
        if ((e.key === 'Enter' || e.key === ',') && inputValue.trim()) {
            e.preventDefault();
            const newTag = inputValue.trim().replace(/^#/, ''); // Strip leading #
            if (newTag && !tags.includes(newTag)) {
                setTags([...tags, newTag]);
            }
            setInputValue('');
        } else if (e.key === 'Backspace' && !inputValue && tags.length > 0) {
            setTags(tags.slice(0, -1));
        }
    };

    const removeTag = (tagToRemove: string) => {
        setTags(tags.filter(tag => tag !== tagToRemove));
    };

    const handleSave = () => {
        onUpdateTags(tags);
        onClose();
    };

    const handleDownload = () => {
        const link = document.createElement('a');
        const fileName = `companion-image-${new Date(image.timestamp).getTime()}.png`;
        link.download = fileName;
        link.href = image.src;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50" onClick={onClose}>
            <div className="bg-card-light dark:bg-card-dark rounded-lg shadow-xl p-4 md:p-6 w-full max-w-5xl mx-4 flex flex-col md:flex-row gap-6 max-h-[90vh]" onClick={e => e.stopPropagation()}>
                <div className="md:w-2/3 flex items-center justify-center bg-background-dark rounded-lg">
                    <img src={image.src} alt={image.prompt} className="w-full h-auto object-contain rounded-lg max-h-[85vh]" />
                </div>
                <div className="md:w-1/3 flex flex-col h-full">
                    <h3 className="text-xl font-bold mb-2 text-text-light dark:text-text-dark">Image Details</h3>
                    <p className="text-sm text-gray-500 dark:text-gray-400 mb-4">Generated on {new Date(image.timestamp).toLocaleString()}</p>
                    <div className="text-sm space-y-2 mb-4 overflow-y-auto pr-2 text-text-light dark:text-text-dark flex-grow">
                        <p><strong>Prompt:</strong> {image.prompt}</p>
                    </div>
                    <div className="mt-auto space-y-4 pt-4 border-t border-border-light dark:border-border-dark">
                        <div>
                            <label className="block text-sm font-medium text-gray-600 dark:text-gray-300 mb-1">Hashtags</label>
                            <div className="w-full p-2 bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark rounded-md flex flex-wrap items-center gap-2 min-h-[42px]">
                                {tags.map(tag => (
                                    <span key={tag} className="flex items-center gap-1 bg-primary text-white text-sm px-2 py-1 rounded-full">
                                        #{tag}
                                        <button onClick={() => removeTag(tag)} className="text-white hover:text-gray-200 focus:outline-none"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></button>
                                    </span>
                                ))}
                                <input type="text" value={inputValue} onChange={handleTagInputChange} onKeyDown={handleTagInputKeyDown} className="flex-grow bg-transparent focus:outline-none" placeholder={tags.length === 0 ? "Add #hashtags..." : "Add another..."} />
                            </div>
                        </div>
                        <div className="flex justify-between items-center gap-2">
                             <button onClick={handleDownload} className="p-2 rounded-md text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500"><DownloadIcon className="w-5 h-5"/></button>
                            <div className="flex gap-2">
                                <button onClick={onClose} className="px-4 py-2 rounded-md text-gray-700 dark:text-gray-300 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500">Close</button>
                                <button onClick={handleSave} className="px-4 py-2 rounded-md bg-primary text-white hover:bg-primary-hover">Save Hashtags</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

const ImageCard: React.FC<{ msgId: string; image: ImageMetadata; onClick: () => void; isSelectMode: boolean; isSelected: boolean; onSelect: () => void; }> = ({ msgId, image, onClick, isSelectMode, isSelected, onSelect }) => {
    const handleClick = () => isSelectMode ? onSelect() : onClick();
    return (
        <div className={`relative group aspect-w-1 aspect-h-1 cursor-pointer`} onClick={handleClick}>
            <img src={image.src} alt={image.prompt} className={`w-full h-full object-cover rounded-lg shadow-md transition-all duration-200 ${isSelected ? 'ring-4 ring-primary ring-offset-2 dark:ring-offset-background-dark' : ''}`} />
            <div className={`absolute inset-0 bg-black transition-all duration-300 ${isSelected ? 'bg-opacity-40' : 'bg-opacity-0 group-hover:bg-opacity-60'}`}>
                {isSelectMode && (<div className="absolute top-2 right-2 text-white">{isSelected ? <CheckSquareIcon className="w-6 h-6" /> : <SquareIcon className="w-6 h-6 opacity-70 group-hover:opacity-100" />}</div>)}
                <div className="absolute bottom-1 left-1 right-1 flex flex-wrap gap-1 p-1">{image.tags.slice(0, 3).map(tag => (<span key={tag} className="bg-primary text-white text-xs px-2 py-1 rounded-full opacity-0 group-hover:opacity-100 transition-opacity duration-300">#{tag}</span>))}</div>
            </div>
        </div>
    );
};


const GalleryView: React.FC<GalleryViewProps> = ({ appState, openSidebar, updateImageTags }) => {
    const [activeTab, setActiveTab] = React.useState<'generated' | 'uploaded'>('generated');
    const [selectedImage, setSelectedImage] = React.useState<ImageMetadata | null>(null);
    const [selectedMessageId, setSelectedMessageId] = React.useState<string | null>(null);
    const [tagFilter, setTagFilter] = React.useState('');
    const [isSelectMode, setIsSelectMode] = React.useState(false);
    const [selectedIds, setSelectedIds] = React.useState<Set<string>>(new Set());

    const { generatedImages, uploadedImages } = React.useMemo(() => {
        const genImgs: { msgId: string, image: ImageMetadata }[] = [];
        const upImgs: { msgId: string, image: ImageMetadata }[] = [];
        appState.chatHistory.forEach(msg => {
            if (msg.image) {
                if (msg.sender === 'ai') {
                    genImgs.push({ msgId: msg.id, image: msg.image });
                } else {
                    upImgs.push({ msgId: msg.id, image: msg.image });
                }
            }
        });
        genImgs.sort((a, b) => new Date(b.image.timestamp).getTime() - new Date(a.image.timestamp).getTime());
        upImgs.sort((a, b) => new Date(b.image.timestamp).getTime() - new Date(a.image.timestamp).getTime());
        return { generatedImages: genImgs, uploadedImages: upImgs };
    }, [appState.chatHistory]);

    const allTags = React.useMemo(() => {
        const tags = new Set<string>();
        [...generatedImages, ...uploadedImages].forEach(item => {
            item.image.tags.forEach(tag => tags.add(tag));
        });
        return Array.from(tags).sort();
    }, [generatedImages, uploadedImages]);

    const filteredImages = React.useMemo(() => {
        const source = activeTab === 'generated' ? generatedImages : uploadedImages;
        if (!tagFilter) {
            return source;
        }
        return source.filter(item => item.image.tags.includes(tagFilter));
    }, [activeTab, generatedImages, uploadedImages, tagFilter]);

    const handleToggleSelect = (msgId: string) => {
        const newSelection = new Set(selectedIds);
        if (newSelection.has(msgId)) {
            newSelection.delete(msgId);
        } else {
            newSelection.add(msgId);
        }
        setSelectedIds(newSelection);
    };
    
    const handleSelectAll = () => {
        setSelectedIds(new Set(filteredImages.map(img => img.msgId)));
    };

    const handleDeselectAll = () => {
        setSelectedIds(new Set());
    };

    const handleBatchDownload = async () => {
        const zip = new JSZip();
        const imagesToDownload = [...generatedImages, ...uploadedImages].filter(item => selectedIds.has(item.msgId));
        
        for (const item of imagesToDownload) {
            const base64Data = item.image.src.split(',')[1];
            zip.file(`image_${item.msgId}.png`, base64Data, { base64: true });
        }

        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = "companion_gallery_export.zip";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        setIsSelectMode(false);
        setSelectedIds(new Set());
    };

    return (
        <div className="flex-1 flex flex-col h-full bg-background-light dark:bg-background-dark overflow-hidden">
            <header className="p-4 border-b border-border-light dark:border-border-dark flex items-center">
                <button onClick={openSidebar} className="md:hidden mr-4 text-text-light dark:text-text-dark" aria-label="Open navigation menu">
                    <MenuIcon className="w-6 h-6" />
                </button>
                <h1 className="text-xl font-semibold text-text-light dark:text-text-dark">Photo Gallery</h1>
            </header>
            <div className="p-4 border-b border-border-light dark:border-border-dark flex flex-wrap items-center gap-4">
                {!isSelectMode ? (
                    <>
                        <div className="flex space-x-2">
                            <button onClick={() => setActiveTab('generated')} className={`px-4 py-2 rounded-md font-medium text-sm ${activeTab === 'generated' ? 'bg-primary text-white' : 'bg-card-light dark:bg-card-dark text-text-light dark:text-text-dark'}`}>
                                Generated ({generatedImages.length})
                            </button>
                            <button onClick={() => setActiveTab('uploaded')} className={`px-4 py-2 rounded-md font-medium text-sm ${activeTab === 'uploaded' ? 'bg-primary text-white' : 'bg-card-light dark:bg-card-dark text-text-light dark:text-text-dark'}`}>
                                Uploaded ({uploadedImages.length})
                            </button>
                        </div>
                        <div className="flex flex-grow items-center gap-2 overflow-x-auto pb-2 -mb-2">
                            <button 
                                onClick={() => setTagFilter('')}
                                className={`flex-shrink-0 px-3 py-1 rounded-full font-medium text-sm transition-colors ${!tagFilter ? 'bg-primary text-white' : 'bg-card-light dark:bg-card-dark text-text-light dark:text-text-dark hover:bg-gray-200 dark:hover:bg-gray-700'}`}
                            >
                                All
                            </button>
                            {allTags.map(tag => (
                                <button 
                                    key={tag} 
                                    onClick={() => setTagFilter(tag)}
                                    className={`flex-shrink-0 px-3 py-1 rounded-full font-medium text-sm transition-colors ${tagFilter === tag ? 'bg-primary text-white' : 'bg-card-light dark:bg-card-dark text-text-light dark:text-text-dark hover:bg-gray-200 dark:hover:bg-gray-700'}`}
                                >
                                    #{tag}
                                </button>
                            ))}
                        </div>
                        <button onClick={() => setIsSelectMode(true)} className="px-4 py-2 ml-auto rounded-md font-medium text-sm bg-secondary text-white">Select</button>
                    </>
                ) : (
                    <div className="w-full flex flex-wrap items-center gap-2">
                        <span className="font-bold">{selectedIds.size} selected</span>
                        <div className="flex gap-2 ml-4">
                             <button onClick={handleSelectAll} className="px-3 py-1 text-sm rounded-md bg-card-light dark:bg-card-dark border border-border-light dark:border-border-dark">Select All</button>
                             <button onClick={handleDeselectAll} className="px-3 py-1 text-sm rounded-md bg-card-light dark:bg-card-dark border border-border-light dark:border-border-dark">Deselect All</button>
                        </div>
                        <div className="ml-auto flex gap-2">
                             <button onClick={() => { setIsSelectMode(false); setSelectedIds(new Set()); }} className="px-4 py-2 rounded-md text-sm bg-gray-500 text-white">Cancel</button>
                             <button onClick={handleBatchDownload} disabled={selectedIds.size === 0} className="px-4 py-2 rounded-md text-sm bg-primary text-white disabled:bg-gray-400">Download Selected</button>
                        </div>
                    </div>
                )}
            </div>
            <div className="flex-1 overflow-y-auto p-6">
                {filteredImages.length > 0 ? (
                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                        {filteredImages.map(({ msgId, image }) => (
                            <ImageCard 
                                key={msgId} 
                                msgId={msgId} 
                                image={image}
                                isSelectMode={isSelectMode}
                                isSelected={selectedIds.has(msgId)}
                                onSelect={() => handleToggleSelect(msgId)}
                                onClick={() => {
                                    setSelectedImage(image);
                                    setSelectedMessageId(msgId);
                                }} 
                            />
                        ))}
                    </div>
                ) : (
                    <div className="text-center text-gray-500 dark:text-gray-400 mt-10">
                        <p>No {activeTab} images found{tagFilter && ' with that tag'}.</p>
                        <p>{activeTab === 'generated' ? 'Ask your companion to generate a photo.' : 'Upload an image in the chat.'}</p>
                    </div>
                )}
            </div>
            {selectedImage && selectedMessageId && (
                <ImageDetailModal
                    msgId={selectedMessageId}
                    image={selectedImage}
                    onClose={() => {
                        setSelectedImage(null);
                        setSelectedMessageId(null);
                    }}
                    onUpdateTags={(tags) => updateImageTags(selectedMessageId, tags)}
                />
            )}
        </div>
    );
};

export default GalleryView;
/* --- FILE: views/DevelopView.tsx --- */
// import * as React from 'react';
// import { AppState, MemoryEntry } from '../types';
// import { generateSelfReflection } from '../services/aiService';
// import { MenuIcon, PlusCircleIcon, EditIcon, TrashIcon, GlobeIcon } from '../components/Icons';

interface MemoriesViewProps {
    appState: AppState;
    addMemory: (content: string) => void;
    updateMemory: (id: string, content: string) => void;
    deleteMemory: (id: string) => void;
    openSidebar: () => void;
}

const MemoryCard: React.FC<{
    entry: MemoryEntry;
    onUpdate: (id: string, content: string) => void;
    onDelete: (id: string) => void;
}> = ({ entry, onUpdate, onDelete }) => {
    const [isEditing, setIsEditing] = React.useState(false);
    const [editContent, setEditContent] = React.useState(entry.content);

    const handleUpdate = () => {
        if (editContent.trim()) {
            onUpdate(entry.id, editContent.trim());
            setIsEditing(false);
        }
    };

    return (
        <div className="bg-card-light dark:bg-card-dark p-4 rounded-lg shadow-sm border border-border-light dark:border-border-dark flex items-center justify-between gap-4">
            {isEditing ? (
                <textarea
                    value={editContent}
                    onChange={(e) => setEditContent(e.target.value)}
                    onBlur={handleUpdate}
                    onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleUpdate(); } }}
                    className="w-full bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark rounded-md p-2 resize-none"
                    rows={2}
                    autoFocus
                />
            ) : (
                <div className="flex-grow">
                    <p className="text-gray-700 dark:text-gray-300">{entry.content}</p>
                    <p className="text-xs text-gray-400 dark:text-gray-500 mt-1">{new Date(entry.date).toLocaleDateString()}</p>
                </div>
            )}
            <div className="flex-shrink-0 flex items-center gap-2">
                <button onClick={() => setIsEditing(!isEditing)} className="text-gray-400 hover:text-primary"><EditIcon className="w-5 h-5" /></button>
                <button onClick={() => onDelete(entry.id)} className="text-gray-400 hover:text-red-500"><TrashIcon className="w-5 h-5" /></button>
            </div>
        </div>
    );
};

const MemoriesView: React.FC<MemoriesViewProps> = ({ appState, addMemory, updateMemory, deleteMemory, openSidebar }) => {
    const [isLoading, setIsLoading] = React.useState(false);
    const [suggestions, setSuggestions] = React.useState<string[]>([]);
    const [error, setError] = React.useState<string | null>(null);
    const [newMemory, setNewMemory] = React.useState('');

    const handleReflect = async () => {
        setIsLoading(true);
        setError(null);
        setSuggestions([]);
        try {
            const newSuggestions = await generateSelfReflection(appState);
            if (newSuggestions.length === 0) {
                setError("I couldn't find any new insights from our recent conversation. Let's chat some more and then try again!");
            } else {
                setSuggestions(newSuggestions);
            }
        } catch (e) {
            setError(e instanceof Error ? e.message : "An unknown error occurred.");
        } finally {
            setIsLoading(false);
        }
    };

    const handleAddSuggestion = (suggestion: string) => {
        addMemory(suggestion);
        setSuggestions(prev => prev.filter(s => s !== suggestion));
    };

    const handleAddManualMemory = () => {
        if (newMemory.trim()) {
            addMemory(newMemory.trim());
            setNewMemory('');
        }
    };
    
    return (
        <div className="flex-1 flex flex-col h-full bg-background-light dark:bg-background-dark overflow-hidden">
            <header className="p-4 border-b border-border-light dark:border-border-dark flex justify-between items-center">
                <div className="flex items-center">
                    <button onClick={openSidebar} className="md:hidden mr-4 text-text-light dark:text-text-dark" aria-label="Open navigation menu"><MenuIcon className="w-6 h-6" /></button>
                    <h1 className="text-xl font-semibold text-text-light dark:text-text-dark">Memories & Development</h1>
                </div>
            </header>
            <div className="flex-1 overflow-y-auto p-6">
                <div className="max-w-4xl mx-auto space-y-12">
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        {/* Left Column: Core Memories */}
                        <div className="space-y-6">
                            <div>
                               <h2 className="text-2xl font-bold mb-4 text-text-light dark:text-text-dark">Core Memories</h2>
                                <div className="flex gap-2 mb-4">
                                    <input
                                        type="text"
                                        value={newMemory}
                                        onChange={(e) => setNewMemory(e.target.value)}
                                        onKeyDown={(e) => e.key === 'Enter' && handleAddManualMemory()}
                                        placeholder="Add a new memory..."
                                        className="w-full p-2 bg-background-light dark:bg-background-dark border border-border-light dark:border-border-dark rounded-md"
                                    />
                                    <button onClick={handleAddManualMemory} className="px-4 py-2 bg-secondary text-white font-semibold rounded-md hover:bg-secondary-hover">Add</button>
                                </div>
                            </div>
                            <div className="space-y-4">
                                {appState.memories.length > 0 ? (
                                    appState.memories.map(entry => (
                                        <MemoryCard key={entry.id} entry={entry} onUpdate={updateMemory} onDelete={deleteMemory} />
                                    ))
                                ) : (
                                    <p className="text-center text-gray-500 dark:text-gray-400 pt-4">No memories yet. Add one manually or use the self-reflection tool.</p>
                                )}
                            </div>
                        </div>

                        {/* Right Column: Self-Reflection */}
                        <div className="space-y-6">
                            <div className="bg-card-light dark:bg-card-dark p-6 rounded-lg shadow-sm border border-border-light dark:border-border-dark">
                                <h2 className="text-xl font-bold mb-2 text-text-light dark:text-text-dark">Self-Reflection</h2>
                                <p className="text-gray-600 dark:text-gray-300 mb-4">
                                    Your companion can analyze your recent conversations to discover new aspects of its personality, likes, and dislikes.
                                </p>
                                <button onClick={handleReflect} disabled={isLoading || appState.chatHistory.length < 5} className="w-full px-6 py-3 bg-primary text-white font-semibold rounded-md hover:bg-primary-hover disabled:bg-gray-400 transition-colors">
                                    {isLoading ? 'Reflecting...' : 'Begin Self-Reflection'}
                                </button>
                                {appState.chatHistory.length < 5 && <p className="text-xs text-center text-gray-500 mt-2">More conversation history needed for reflection.</p>}
                            </div>

                            {isLoading && <div className="text-center py-10"><div className="w-10 h-10 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto"></div></div>}
                            {error && <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md" role="alert"><p>{error}</p></div>}

                            {suggestions.length > 0 && (
                                <div>
                                    <h3 className="text-lg font-bold text-text-light dark:text-text-dark mb-3">Suggested New Memories</h3>
                                    <ul className="space-y-3">
                                        {suggestions.map((suggestion, index) => (
                                            <li key={index} className="flex items-center justify-between p-3 bg-background-light dark:bg-background-dark rounded-md border border-border-light dark:border-border-dark">
                                                <p className="text-gray-700 dark:text-gray-300 flex-grow italic">"{suggestion}"</p>
                                                <button onClick={() => handleAddSuggestion(suggestion)} title="Add to Core Memory" className="ml-4 p-2 text-gray-400 hover:text-primary transition-colors"><PlusCircleIcon className="w-6 h-6" /></button>
                                            </li>
                                        ))}
                                    </ul>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Interaction Guide Section */}
                    <div className="bg-indigo-50 dark:bg-indigo-900/20 p-8 rounded-xl border border-indigo-100 dark:border-indigo-800">
                        <div className="flex items-center gap-3 mb-6">
                            <div className="p-2 bg-indigo-500 rounded-lg text-white">
                                <GlobeIcon className="w-6 h-6" />
                            </div>
                            <h2 className="text-2xl font-bold text-indigo-900 dark:text-indigo-100">Interaction Guide</h2>
                        </div>
                        
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                            <div>
                                <h3 className="text-lg font-bold text-indigo-800 dark:text-indigo-200 mb-2 underline decoration-indigo-300">Out Of Character (OOC)</h3>
                                <p className="text-gray-700 dark:text-gray-300 leading-relaxed">
                                    Wrap your text in parentheses <code className="bg-indigo-200 dark:bg-indigo-800 px-1 rounded font-bold">(like this)</code> to talk directly to the AI core instead of the character. 
                                </p>
                                <ul className="mt-4 space-y-2 text-sm text-gray-600 dark:text-gray-400">
                                    <li className="flex items-start gap-2">
                                        <div className="w-1.5 h-1.5 rounded-full bg-indigo-400 mt-1.5 flex-shrink-0"></div>
                                        <span>Correct behavior: <span className="italic">"(Please don't be so sarcastic right now.)"</span></span>
                                    </li>
                                    <li className="flex items-start gap-2">
                                        <div className="w-1.5 h-1.5 rounded-full bg-indigo-400 mt-1.5 flex-shrink-0"></div>
                                        <span>Change scenario: <span className="italic">"(Let's pretend we just arrived at a futuristic space station.)"</span></span>
                                    </li>
                                    <li className="flex items-start gap-2">
                                        <div className="w-1.5 h-1.5 rounded-full bg-indigo-400 mt-1.5 flex-shrink-0"></div>
                                        <span>Meta-questions: <span className="italic">"(Why did you respond that way based on your persona?)"</span></span>
                                    </li>
                                </ul>
                            </div>
                            
                            <div>
                                <h3 className="text-lg font-bold text-indigo-800 dark:text-indigo-200 mb-2 underline decoration-indigo-300">Character Immersion</h3>
                                <p className="text-gray-700 dark:text-gray-300 leading-relaxed">
                                    Normal messages go to the character. Your companion uses asterisks to describe actions and feelings, and expects the same from you for deep immersion.
                                </p>
                                <ul className="mt-4 space-y-2 text-sm text-gray-600 dark:text-gray-400">
                                    <li className="flex items-start gap-2">
                                        <div className="w-1.5 h-1.5 rounded-full bg-indigo-400 mt-1.5 flex-shrink-0"></div>
                                        <span>Describe actions: <span className="italic">"*I wave goodbye and start walking away slowly.*"</span></span>
                                    </li>
                                    <li className="flex items-start gap-2">
                                        <div className="w-1.5 h-1.5 rounded-full bg-indigo-400 mt-1.5 flex-shrink-0"></div>
                                        <span>Express feelings: <span className="italic">"*I feel a sense of relief wash over me.*"</span></span>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default MemoriesView;
/* --- ENTRY: index.tsx --- */
// import * as React from 'react';
// import ReactDOM from 'react-dom/client';
// import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

    </script>
</body>
</html>